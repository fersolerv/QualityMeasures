#include "MVBB.h"
using namespace std;

MVBB::MVBB() {}
MVBB::~MVBB(){}

bool MVBB::compute_bbox(std::string graspPointCloudPath,
                        std::string objectPointCloudPath,
                        pcl::PointCloud<pcl::PointXYZ>::Ptr &Original_filtered, 
                        pcl::PointCloud<pcl::PointXYZ>::Ptr &Cloud_out,
                        pcl::PointCloud<pcl::Normal>::Ptr &object_normals, 
                        pcl::PointCloud<pcl::Normal>::Ptr &object_normals_out, 
                        Eigen::Vector3f &CM) 
                        {

    pcl::PointCloud<pcl::PointXYZ>::Ptr Original(new pcl::PointCloud<pcl::PointXYZ>);
    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_grasp(new pcl::PointCloud<pcl::PointXYZ>);
    pcl::PointCloud<pcl::PointXYZ>::Ptr Cloud_In(new pcl::PointCloud<pcl::PointXYZ>);
    Eigen::Quaternionf Rotation;
    Eigen::Vector3f Translation;
    Eigen::Vector4f Min, Max;
    Eigen::Matrix4f Projection;
    double object_area;

    //  if change object, change path
    const char *absPath1 = "/home/fernando/PHD/Experiments/grasps/CookieBox/box30.xml";
    const char *absPath2 = "/home/fernando/PHD/Experiments/grasps/BabyBottle/GraspTransforms30.txt";
    const char *absPath3 = "/home/fernando/PHD/Experiments/grasps/CookieBox/GraspsQuality30.txt";
    //const char *absPath4 = "/home/fernando/PHD/Experiments/grasps/Box/box200.xml";
    //const char *absPath5 = "/home/fernando/PHD/Experiments/grasps/Box/SortQualities1.txt";

    loadPointCloud(graspPointCloudPath, cloud_grasp); //TODO: Test
    loadPointCloud(objectPointCloudPath, Original);   //TODO: Test
    cloud_filter(Original, Original_filtered);
    computeNormals(Original_filtered, object_normals,CM);
    compute_BBox(cloud_grasp, Rotation, Translation, Min, Max, Projection);
    
    //getGraspQuality(absPath1, absPath3);
    //getTransforms(absPath1, absPath2);
    //QualitySort(absPath4, absPath5);
    
    cropFilters(Original_filtered,object_normals,Min,Max,Projection,Cloud_out,Cloud_In,object_normals_out);
    // ModelConstruct(Original_filtered, object_area);
    // ModelConstruct2(Cloud_out, object_area);
    visualize(cloud_grasp,Cloud_out,CM,Cloud_In,Min,Max,Rotation,Translation,false);
    return true;
}

bool MVBB::loadPointCloud(string path, pcl::PointCloud<pcl::PointXYZ>::Ptr &pointCloud) {
    if (pcl::io::loadPCDFile<pcl::PointXYZ> (path, *pointCloud) == -1) {
        PCL_ERROR ("Couldn't read file .pcd \n");
        return false;
    }
    cout << "Point cloud file loaded with " << pointCloud->points.size() << " points" << endl;
}

bool MVBB::read_points(pcl::PointCloud<pcl::PointXYZ>::Ptr &C_Object, 
                       pcl::PointCloud<pcl::Normal>::Ptr &Normals) 
                       {
    std::fstream Obj;
    std::vector<std::vector <double>> points;
    std::vector<std::vector <double>> norms;
    std::vector<double> point;
    std::vector<double> norm;
    double val_point, val_norm;
    points.clear();
    norms.clear();
    Obj.open("/home/fernando/PHD/Applications/VRMLtoPCD/build/out/Object.txt");
    //read txt file that contains the points and normals provided by simox
    if(Obj.is_open()) {
        do {
            if (Obj.eof()) {
                break;
                return false;
            }
            point.clear();
            norm.clear();
            for(int i = 0; i < 6; i ++) {
                if(i < 3) 
                    Obj >> val_point;
                else 
                    Obj >> val_norm;
                point.push_back(val_point);
                norm.push_back(val_norm);
            }
            points.push_back(point);
            norms.push_back(norm);
        } while (!Obj.eof());

        //Convert the points into PCL format
        C_Object->resize(points.size());
        Normals->resize(norms.size());

        for(size_t j = 0; j < points.size(); j++) {
            C_Object->points[j].x = points.at(j).at(0);
            C_Object->points[j].y = points.at(j).at(1);
            C_Object->points[j].z = points.at(j).at(2);
        }

        for(size_t k = 0; k < norms.size(); k++) {
            Normals->points[k].normal[0] = norms.at(k).at(0);
            Normals->points[k].normal[0] = norms.at(k).at(1);
            Normals->points[k].normal[0] = norms.at(k).at(2);
        }

    }
    else 
        return false;
    return true;
}

void MVBB::cloud_filter(pcl::PointCloud<pcl::PointXYZ>::Ptr Original, 
                        pcl::PointCloud<pcl::PointXYZ>::Ptr &Filtered)
                        {
    if (Original->points.size() > 90000) {
        pcl::octree::OctreePointCloudSearch<pcl::PointXYZ > octree (128.0f);
        octree.setInputCloud(Original);
        octree.addPointsFromInputCloud();
        double sampling = 2.8;
        pcl::VoxelGrid<pcl::PointXYZ> voxfilter;
        voxfilter.setInputCloud (Original);
        voxfilter.setLeafSize (sampling, sampling, sampling);
        voxfilter.filter(*Filtered);
    }
    else Filtered = Original;
    cout << "Object point cloud filtered with " << Filtered->points.size() << " points" << endl;
}

void MVBB::getGraspQuality(const char *absPath1, 
                           const char *absPath3) 
                           { //get the quality of each grasp from the .xml file  and save them into a .txt file
    ofstream GraspQuality(absPath3);
    double quality;
    pugi::xml_document doc;
    //Load .xml file
    pugi::xml_parse_result result = doc.load_file(absPath1);
    if (!result) std::cout << "Parse error: " << result.description() << ", character pos = " << result.offset<<std::endl;
    else std::cout << "Problem file loaded"<<std::endl;
    int i = 0;
    for(pugi::xml_node tool = doc.child("ManipulationObject").child("GraspSet").child("Grasp"); tool; tool = tool.next_sibling("Grasp")) {
        quality = tool.attribute("quality").as_double();
        GraspQuality << quality << endl;
        std::cout << quality << std::endl;
        i++;
    }
}

void MVBB::getTransforms(const char *absPath1, 
                         const char *absPath2) 
                         {   //get the matrix transformation of each grasp from the .xml file and save them into a .txt file

    ofstream transform(absPath2);
    double xx, xy, xz, yx, yy, yz, zx, zy, zz, x1, y1, z1, p1, p2, p3, p4;
    pugi::xml_document doc;
    //Load .xml file
    pugi::xml_parse_result result = doc.load_file(absPath1);
    if (!result) std::cout << "Parse error: " << result.description() << ", character pos = " << result.offset<<std::endl;
    else std::cout << "Problem file loaded"<<std::endl;
    int i = 0;
    for(pugi::xml_node tool = doc.child("ManipulationObject").child("GraspSet").child("Grasp"); tool; tool = tool.next_sibling("Grasp")){

        pugi::xml_node node = tool.child("Transform").child("Matrix4x4").child("row1");
        xx = node.attribute("c1").as_double();
        xy = node.attribute("c2").as_double();
        xz = node.attribute("c3").as_double();
        x1 = node.attribute("c4").as_double();

        node = tool.child("Transform").child("Matrix4x4").child("row2");

        yx = node.attribute("c1").as_double();
        yy = node.attribute("c2").as_double();
        yz = node.attribute("c3").as_double();
        y1 = node.attribute("c4").as_double();

        node = tool.child("Transform").child("Matrix4x4").child("row3");

        zx = node.attribute("c1").as_double();
        zy = node.attribute("c2").as_double();
        zz = node.attribute("c3").as_double();
        z1 = node.attribute("c4").as_double();

        node = tool.child("Transform").child("Matrix4x4").child("row4");

        p1 = node.attribute("c1").as_double();
        p2 = node.attribute("c2").as_double();
        p3 = node.attribute("c3").as_double();
        p4 = node.attribute("c4").as_double();

        transform << xx << ", ";
        transform << xy << ", ";
        transform << xz << ", ";
        transform << x1 << ", ";

        transform << yx << ", ";
        transform << yy << ", ";
        transform << yz << ", ";
        transform << y1 << ", ";

        transform << zx << ", ";
        transform << zy << ", ";
        transform << zz << ", ";
        transform << z1 << ", ";

        transform << p1 << ", ";
        transform << p2 << ", ";
        transform << p3 << ", ";
        transform << p4 << ";" << endl;

        //cout << "Transform (" << i << ") " << xx << " " << xy << " " << xz << " " << x1 << " " << yx << " " << yy << " " << yz << " " << y1 << " " << zx << " " << zy << " " << zz << " " << z1
        //     << " " << p1 << " " << p2 << " " << p3 << " " << p4 << endl;
        i++;
    }
}

void MVBB::QualitySort(const char *absPath4, 
                       const char *absPath5) 
                      {

    ofstream GraspQuality(absPath5);
    double quality;
    pugi::xml_document doc;
    //Load .xml file
    pugi::xml_parse_result result = doc.load_file(absPath4);
    if (!result){
        std::cout << "Parse error: " << result.description()
                  << ", character pos = " << result.offset<<std::endl;
    }
    else{
        std::cout << "Problem file loaded"<<std::endl;
    }

    for(pugi::xml_node tool = doc.child("ManipulationObject").child("GraspSet").child("Grasp"); tool; tool = tool.next_sibling("Grasp")){

        int i = 0;
        quality = tool.attribute("quality").as_double();
        GraspQuality << quality << endl;
        i++;
    }

    // Open your text file
    std::ifstream file("/home/fernando/PHD/Experiments/grasps/Coffee_mug/SortQualities.txt");
    std::vector<std::string> rows;

    // Read all the lines and add them to the rows vector
    while(!file.eof())
    {
        std::string line;
        std::getline(file, line);
        rows.push_back(line);
    }

    // Sort the vector
    std::sort(rows.begin(), rows.end());

    // Print out all of the vectors values
    std::vector<std::string>::iterator iterator = rows.begin();
    for(; iterator != rows.end(); ++iterator)
        //std::cout << *iterator << std::endl;
        getchar();
}

void MVBB::compute_BBox(pcl::PointCloud<pcl::PointXYZ>::Ptr &Hand_configuration, 
                        Eigen::Quaternionf &BBox_Rotation,
                        Eigen::Vector3f &BBox_Translation, 
                        Eigen::Vector4f &Min, 
                        Eigen::Vector4f &Max, 
                        Eigen::Matrix4f &Projection)
                        {

    //Define a rotation matrix
    Eigen::Matrix4f transform;
    transform = Eigen::Matrix4f::Identity();

    //////////////////////////////////////////////////////
    transform <<

///Sport Bottle
//    0.495063, 0.17581, 0.850884, 27.5527, -0.838295, 0.354105, 0.414573, 15.5333, -0.228416, -0.918532, 0.322684, 39.7708, 0, 0, 0, 1;
//    -0.452702, 0.891122, 0.0310351, 53.5946, 0.863882, 0.446952, -0.232254, 55.1454, -0.220838, -0.0783311, -0.97216, 186.654, 0, 0, 0, 1;
//    0.638274, -0.1858, -0.74705, 145.983, -0.567068, -0.769778, -0.293046, 63.2545, -0.520615, 0.610672, -0.596691, 137.062, 0, 0, 0, 1;
//    -0.880382, -0.372439, -0.293627, 92.5134, -0.335052, 0.0502416, 0.940859, -127.786, -0.33566, 0.926696, -0.169018, 61.1154, 0, 0, 0, 1;
//    0.534779, -0.818065, 0.211616, 34.6299, -0.266434, -0.400907, -0.876519, 62.4309, 0.801889, 0.412362, -0.432357, 92.5385, 0, 0, 0, 1;
//    -0.536001, 0.830944, -0.149112, 64.9208, 0.843432, 0.51947, -0.137012, 44.978, -0.0363903, -0.199205, -0.979282, 205.572, 0, 0, 0, 1;
//    0.512013, -0.0599494, -0.856883, 167.555, -0.827481, 0.233234, -0.510762, 95.6332, 0.230474, 0.970571, 0.0698118, 39.1974, 0, 0, 0, 1;
//    0.903815, -0.410722, -0.120108, 72.4946, 0.339158, 0.858692, -0.384214, 113.55, 0.260941, 0.306523, 0.915398, -103.45, 0, 0, 0, 1;
//    -0.435727, -0.801461, -0.409637, 112.598, -0.893545, 0.439908, 0.0897708, 23.509, 0.108255, 0.405145, -0.907821, 162.361, 0, 0, 0, 1;
//    -0.288507, 0.0168567, 0.957329, 30.4613, -0.929982, 0.232955, -0.284368, 28.1508, -0.227809, -0.972341, -0.0515328, 45.9518, 0, 0, 0, 1;
//    -0.215345, 0.952419, -0.215693, 77.4894, 0.976487, 0.212268, -0.0376181, 24.4707, 0.00995652, -0.218723, -0.975736, 192.89, 0, 0, 0, 1;
//    -0.578427, -0.775235, 0.253836, 32.3929, -0.811035, 0.513189, -0.280819, 37.0098, 0.0874353, -0.368303, -0.925585, 139.179, 0, 0, 0, 1;
//    0.263012, -0.829302, -0.493034, 116.094, -0.735648, 0.158249, -0.658619, 125.714, 0.624216, 0.535924, -0.568453, 122.068, 0, 0, 0, 1;
//    -0.716994, 0.695568, 0.0458691, 44.2339, 0.696996, 0.714343, 0.0625318, 11.27, 0.0107289, 0.0768055, -0.996988, 179.55, 0, 0, 0, 1;
//    0.773418, -0.0509284, -0.631847, 147.321, -0.598509, -0.387048, -0.701413, 168.013, -0.208833, 0.920652, -0.329831, 64.5585, 0, 0, 0, 1;
//    0.262373, 0.953369, -0.149157, 81.8523, -0.877375, 0.300038, 0.374419, -58.2981, 0.401712, 0.0326294, 0.915184, -104.113, 0, 0, 0, 1;
//    0.883796, -0.142008, -0.4458, 111.866, -0.136747, -0.989622, 0.0441424, 20.3348, -0.447442, 0.0219489, -0.894043, 176.803, 0, 0, 0, 1;
//    0.997135, -0.0660158, -0.0369156, 50.79, 0.0167518, -0.283194, 0.958916, -92.5598, -0.073758, -0.956788, -0.281276, 89.0744, 0, 0, 0, 1;
//    0.189911, 0.884371, -0.426406, 111.816, 0.978954, -0.137518, 0.15079, -8.06567, 0.0747162, -0.446069, -0.891874, 158.373, 0, 0, 0, 1;
//    -0.713199, 0.488225, 0.502975, 41.3136, -0.486308, 0.172144, -0.856662, 39.6983, -0.504828, -0.855572, 0.114655, 44.1179, 0, 0, 0, 1;
//    -0.511762, 0.104666, 0.852728, 41.5893, 0.41208, 0.900829, 0.136738, 31.2623, -0.75385, 0.42137, -0.504141, 53.0295, 0, 0, 0, 1;
//    0.692365, 0.581062, -0.427783, 104.559, 0.317147, 0.28746, 0.903762, -96.0971, 0.648112, -0.761403, 0.0147457, 54.0277, 0, 0, 0, 1;
//    0.46005, -0.101989, -0.882016, 170.023, -0.660138, -0.703612, -0.262961, 59.5236, -0.593778, 0.703227, -0.391023, 102.574, 0, 0, 0, 1;
//    0.716411, -0.0943671, -0.691267, 142.127, 0.658825, -0.23453, 0.714805, -77.3641, -0.229577, -0.967518, -0.105848, 60.0651, 0, 0, 0, 1;
//    -0.374757, -0.627384, 0.682602, 28.2388, 0.911941, -0.382142, 0.149438, -4.27688, 0.167096, 0.678496, 0.715348, 36.7721, 0, 0, 0, 1;
//    0.620844, -0.78155, -0.0610844, 49.4686, -0.445885, -0.28796, -0.847505, 143.904, 0.644779, 0.553405, -0.52726, 141.366, 0, 0, 0, 1;
//    -0.303678, -0.952775, 5.0908e-09, 50.1608, 0.952775, -0.303678, -1.59721e-08, 32.1454, 2.12962e-08, -6.78774e-09, 1, 6.73551, 0, 0, 0, 1;
//    0.967852, 0.0133542, -0.251162, 79.3529, 0.240804, -0.337531, 0.909992, -99.2109, -0.0726229, -0.94122, -0.329896, 97.0194, 0, 0, 0, 1;
//    -0.809747, 0.147328, -0.567983, 166.576, 0.0482915, 0.981415, 0.18572, -10.2146, 0.584789, 0.122957, -0.801813, 139.679, 0, 0, 0, 1;
//    -0.804536, 0.40651, 0.432979, 19.3208, 0.417632, -0.131103, 0.899108, -46.4465, 0.422261, 0.904191, -0.064294, 119.924, 0, 0, 0, 1;

/// Cookie Box
//    0.048396, 0.732436, -0.679114, 30.5616, -0.0163503, -0.679239, -0.733735, -9.20028, -0.998694, 0.0466135, -0.0208969, 97.867, 0, 0, 0, 1;
//    -0.143147, -0.193771, 0.970547, 175.589, -0.169066, 0.97102, 0.16893, 24.916, -0.975154, -0.139905, -0.171759, 80.5098, 0, 0, 0, 1;
//    0.9626, 0.158102, -0.220013, 101.606, 0.246168, -0.171239, 0.95398, 38.6626, 0.113151, -0.972461, -0.203754, 45.7493, 0, 0, 0, 1;
//    0.351049, 0.0555584, 0.934707, 152.803, 0.93444, 0.0430525, -0.353508, 9.61545, -0.0598818, 0.997527, -0.0368025, 123.219, 0, 0, 0, 1;
//    0.988816, 0.032314, 0.145595, 115.078, -0.118624, -0.42128, 0.899139, 22.5522, 0.090391, -0.906355, -0.412735, 44.0878, 0, 0, 0, 1;
//    -0.2449, -0.154528, 0.957155, 166.512, 0.723384, 0.628195, 0.286506, 0.623829, -0.645553, 0.762556, -0.0420617, 78.6433, 0, 0, 0, 1;
//    -0.843635, -0.527083, 0.102291, 115.803, -0.481224, 0.657784, -0.579434, -62.2478, 0.238124, -0.538055, -0.808575, -49.2267, 0, 0, 0, 1;
//    0.851788, 0.0201251, -0.523499, 104.237, -0.523694, 0.00567251, -0.851887, -1.38159, -0.0141748, 0.999781, 0.0153712, 36.2199, 0, 0, 0, 1;
//    -0.734498, -0.0250958, -0.678146, 102.597, 0.67761, -0.0813661, -0.730906, -35.8689, -0.0368355, -0.996369, 0.0767684, 51.7485, 0, 0, 0, 1;
//    0.0583283, 0.0798022, -0.995103, 39.8748, 0.83837, 0.537243, 0.0922254, -71.7468, 0.541972, -0.839643, -0.0355672, -5.98874, 0, 0, 0, 1;
//    -0.84765, 0.279913, -0.450708, 105.305, 0.206177, -0.608948, -0.765947, 29.1215, -0.488856, -0.742181, 0.458463, 83.2719, 0, 0, 0, 1;
//    -0.335202, -0.720969, 0.606501, 151.806, -0.941864, 0.272196, -0.196982, -26.9804, -0.0230694, -0.637269, -0.770296, -62.4741, 0, 0, 0, 1;
//    0.945163, -0.28627, 0.157214, 114.363, 0.144772, -0.0642599, -0.987376, 39.0885, 0.292759, 0.955992, -0.0192922, 60.9087, 0, 0, 0, 1;
//    -0.0286451, -0.141302, -0.989552, 52.3257, -0.713458, -0.690477, 0.119248, 76.2114, -0.700113, 0.709419, -0.0810339, 84.5844, 0, 0, 0, 1;
//    0.435985, 0.878957, -0.193268, 56.3416, 0.0937586, 0.169223, 0.981108, 33.0997, 0.895057, -0.445869, -0.00863087, 154.147, 0, 0, 0, 1;
//    0.555877, 0.397413, -0.730112, 66.2427, 0.827697, -0.18333, 0.530384, 69.7403, 0.0769299, -0.89914, -0.430847, 54.1508, 0, 0, 0, 1;
//    -0.0793516, 0.975686, 0.204302, 60.8016, 0.00156768, -0.204826, 0.978797, 161.412, 0.996845, 0.0779893, 0.0147237, 119.625, 0, 0, 0, 1;
//    0.231811, -0.804735, -0.546502, 32.5333, 0.180577, -0.516441, 0.837066, 68.3755, -0.955853, -0.292727, 0.0256, 102.98, 0, 0, 0, 1;
//    -0.127025, 0.106675, -0.986147, 41.8971, -0.991869, -0.0214905, 0.125437, -26.6235, -0.00781184, 0.994062, 0.108537, 34.9037, 0, 0, 0, 1;
//    -0.954354, -0.0212214, 0.297924, 122.998, -0.297952, -0.00193078, -0.954579, 18.1229, 0.0208327, -0.999773, -0.00448036, 45.0692, 0, 0, 0, 1;
//    -0.915318, -0.349054, -0.200885, 84.148, -0.394944, 0.680357, 0.61736, 160.8, -0.0788182, 0.644419, -0.760599, -80.2427, 0, 0, 0, 1;
//    -0.0168333, -0.0517276, -0.998519, 38.8543, 0.0247383, -0.998377, 0.0513031, 9.77376, -0.999552, -0.023838, 0.0180857, 97.482, 0, 0, 0, 1;
//    0.269688, -0.133104, 0.953704, 169.871, 0.958792, 0.129026, -0.253119, -15.911, -0.0893617, 0.982668, 0.162416, 54.1767, 0, 0, 0, 1;
//    0.143172, 0.139315, -0.979844, 35.9676, 0.537045, 0.820669, 0.195155, 50.7636, 0.831315, -0.554161, 0.0426786, 95.6794, 0, 0, 0, 1;
//    -0.98151, 0.187975, -0.0361031, 121.649, 0.190666, 0.976764, -0.0978717, 22.0066, 0.0168668, -0.102946, -0.994544, 11.9845, 0, 0, 0, 1;
//    0.112135, -0.873171, -0.474339, 23.1259, 0.0160162, -0.4757, 0.879462, 103.691, -0.993564, -0.106215, -0.0393575, 95.5907, 0, 0, 0, 1;
//    0.483458, -0.0417133, 0.874373, 150.853, -0.875335, -0.0144266, 0.483301, 107.779, -0.0075458, -0.999026, -0.0434878, 37.7837, 0, 0, 0, 1;
//    -0.426705, -0.904255, -0.0156241, 81.9802, -0.904303, 0.426841, -0.00658347, 86.083, 0.0126221, 0.0113197, -0.999856, 21.5875, 0, 0, 0, 1;
//    0.829154, -0.0664927, 0.555052, 163.903, 0.55612, -0.00289725, -0.831097, -12.9705, 0.0568701, 0.997783, 0.0345756, 45.9829, 0, 0, 0, 1;
//    -0.0308601, 0.0693727, 0.997114, 178.331, 0.0554937, -0.995931, 0.0710079, 61.5119, 0.997982, 0.0575248, 0.0268847, 94.4105, 0, 0, 0, 1;

///Detergent Bottle:
//    -0.894, -0.425113, -0.14157, 0.192867, -0.426368, 0.90426, -0.0228842, -0.0789124, 0.137744, 0.0399023, -0.989664, -0.0334032, 0, 0, 0, 1;                       //1
    0.747093, -0.649495, 0.141449, 0.189872, 0.521595, 0.704717, 0.48095, -0.130538, -0.412056, -0.285535, 0.865262, 0.104591, 0, 0, 0, 1;
//    0.677348, -0.200986, 0.707675, 0.0806172, 0.241324, 0.969431, 0.0443442, -0.0815476, -0.694955, 0.140743, 0.705145, 0.0739862, 0, 0, 0, 1;
//    -0.741047, -0.196248, -0.642136, 0.131943, -0.668643, 0.303106, 0.679004, -0.0365476, 0.0613813, 0.932531, -0.355835, -0.0567221, 0, 0, 0, 1;
//    -0.152325, -0.375763, 0.914111, 0.117588, 0.768017, -0.627134, -0.129815, 0.13032, 0.62205, 0.682279, 0.384121, -0.0521552, 0, 0, 0, 1;                          //5
//    0.836803, -0.413125, 0.359289, 0.164366, -0.530056, -0.775644, 0.342661, 0.148588, 0.137119, -0.477183, -0.868041, 0.0667507, 0, 0, 0, 1;
//    -0.134952, 0.977163, -0.164141, 0.0196054, -0.967722, -0.0943972, 0.233671, 0.0626589, 0.21284, 0.190377, 0.958361, 0.00730307, 0, 0, 0, 1;
//    -0.890718, 0.437058, 0.124904, 0.090065, -0.454221, -0.845262, -0.281453, 0.159265, -0.0174345, -0.307429, 0.951411, 0.0525473, 0, 0, 0, 1;
//    -0.314041, 0.304757, -0.899167, 0.071779, 0.445451, 0.883661, 0.143925, -0.111096, 0.838423, -0.355337, -0.41326, 0.0347353, 0, 0, 0, 1;
//    -0.64266, 0.281351, 0.712622, 0.0670237, -0.0788945, -0.949489, 0.30372, 0.128964, 0.762079, 0.138967, 0.632395, 0.0358005, 0, 0, 0, 1;                       //10
//    -0.277325, 0.901765, -0.331527, 0.0393751, -0.951461, -0.209836, 0.225145, 0.0600977, 0.133461, 0.377874, 0.916187, -0.00638588, 0, 0, 0, 1;
//    -0.153445, -0.553919, 0.818308, 0.1727, 0.829786, 0.377441, 0.41109, -0.0227826, -0.536574, 0.742101, 0.401716, -0.0277035, 0, 0, 0, 1;
//    -0.799734, 0.527974, -0.285777, 0.0915228, 0.600343, 0.700461, -0.385929, -0.0633456, -0.00358519, -0.480205, -0.877149, 0.0860111, 0, 0, 0, 1;
//    -0.421162, -0.825278, -0.376215, 0.210891, -0.578559, 0.563899, -0.58931, -0.00701181, 0.698492, -0.0305323, -0.714966, -0.0144037, 0, 0, 0, 1;
//    -0.806569, -0.21392, -0.551077, 0.122444, 0.581455, -0.119027, -0.804825, -0.00174551, 0.106575, -0.969572, 0.220388, 0.191574, 0, 0, 0, 1;                    //15
//    0.562126, -0.366721, 0.741303, 0.133776, 0.225659, -0.794304, -0.564057, 0.130252, 0.795671, 0.484352, -0.363745, -0.0446702, 0, 0, 0, 1;
//    -0.43317, 0.251769, 0.865434, 0.0892409, -0.379269, -0.921961, 0.078381, 0.138794, 0.81763, -0.29428, 0.494854, 0.0217051, 0, 0, 0, 1;
//    -0.285034, -0.34975, -0.892429, 0.133822, -0.701286, 0.710787, -0.0545784, -0.0804433, 0.653417, 0.610292, -0.447874, -0.0642749, 0, 0, 0, 1;
//    -0.116189, -0.961375, 0.249516, 0.265786, 0.853615, 0.0317782, 0.519934, -0.00712871, -0.507781, 0.273401, 0.816952, -0.0307571, 0, 0, 0, 1;
//    0.322982, 0.134904, -0.936741, 0.0762597, -0.945601, 0.0867997, -0.313536, 0.0398251, 0.0390115, 0.987049, 0.1556, 0.00964938, 0, 0, 0, 1;               //20
//    0.838487, 0.490391, -0.237603, 0.0661984, -0.544056, 0.728821, -0.415718, -0.0478446, -0.0306944, 0.477844, 0.877908, -0.0197403, 0, 0, 0, 1;
//    -0.933943, 0.349172, -0.0763552, 0.0866031, -0.337448, -0.93181, -0.133639, 0.173511, -0.117811, -0.0990447, 0.988084, 0.0637835, 0, 0, 0, 1;
//    -0.473788, 0.344543, -0.810441, 0.0963687, 0.879283, 0.134043, -0.457049, 0.012214, -0.0488391, -0.929152, -0.366459, 0.148524, 0, 0, 0, 1;
//    -0.486667, -0.409319, 0.77176, 0.138672, 0.589794, 0.497752, 0.635914, -0.0461, -0.644437, 0.764657, -0.000825614, -0.0105975, 0, 0, 0, 1;
//    -0.0171587, -0.379214, -0.92515, 0.0964049, -0.833887, 0.515954, -0.196021, -0.0016506, 0.551669, 0.768107, -0.325074, -0.00643396, 0, 0, 0, 1;
//    0.895254, -0.233342, 0.379568, 0.130585, 0.403605, 0.785578, -0.46901, -0.124516, -0.18874, 0.573079, 0.79747, -0.0785771, 0, 0, 0, 1;
//    0.408434, -0.871462, 0.271542, 0.23668, 0.844014, 0.473847, 0.251216, -0.0755206, -0.347595, 0.12658, 0.929062, 0.0430817, 0, 0, 0, 1;
//    -0.598378, -0.344505, -0.723367, 0.128862, -0.677488, 0.699543, 0.227267, -0.00963944, 0.427732, 0.626064, -0.651989, -0.0256536, 0, 0, 0, 1;
//    -0.740807, -0.59043, -0.32031, 0.170837, 0.629643, -0.776485, -0.0249275, 0.172239, -0.233998, -0.220147, 0.946985, 0.133324, 0, 0, 0, 1;
//    0.19715, -0.932201, -0.303534, 0.244754, -0.967747, -0.234578, 0.0918618, 0.0858748, -0.156836, 0.275634, -0.948382, 0.000376011, 0, 0, 0, 1;

///Milk Box:
//    0.870887, 0.113059, 0.478301, 31.2875, -0.477561, -0.0353253, 0.877888, -58.1445, 0.116149, -0.99296, 0.0232279, 54.6036, 0, 0, 0, 1;
//    -0.966166, 0.0123313, -0.257626, 96.1256, -0.251838, -0.260761, 0.931977, -33.5647, -0.0556865, 0.965325, 0.255044, 15.2372, 0, 0, 0, 1;
//    0.738939, -0.0927634, -0.667356, 192.396, -0.673488, -0.130432, -0.7276, 124.331, -0.0195496, 0.987108, -0.158856, 56.1819, 0, 0, 0, 1;
//    0.644352, -0.391314, 0.657027, 21.4419, 0.737938, 0.0927433, -0.668466, 8.93398, 0.200645, 0.915572, 0.348525, 57.108, 0, 0, 0, 1;
//    0.737199, -0.130645, -0.662925, 194.268, 0.668762, 0.281078, 0.688297, -110.955, 0.096411, -0.95075, 0.294581, -34.4816, 0, 0, 0, 1;
//    0.198322, 0.289484, -0.936412, 243.042, -0.0604867, 0.957183, 0.283095, -89.0224, 0.978269, 0.000496578, 0.20734, -18.3368, 0, 0, 0, 1;
//    -0.00225838, -0.998022, 0.0628263, 55.2107, 0.877831, 0.0281132, 0.478144, -19.3278, -0.478965, 0.0562308, 0.876031, -38.3378, 0, 0, 0, 1;
//    0.864507, -0.4069, 0.295058, 38.5988, 0.474855, 0.468795, -0.744812, 51.3024, 0.164742, 0.784005, 0.598495, 33.2337, 0, 0, 0, 1;
//    -0.845952, -0.509145, 0.158543, 45.0748, 0.380699, -0.784812, -0.489018, 42.9357, 0.373407, -0.353329, 0.857745, -4.07394, 0, 0, 0, 1;
//    0.0113635, 0.99881, 0.0474297, 70.8465, -0.112178, -0.0458599, 0.992629, -54.3695, 0.993623, -0.0166004, 0.111523, 18.9966, 0, 0, 0, 1;
//    0.0536162, 0.985053, -0.163693, 86.8229, -0.0633525, -0.160243, -0.985042, 153.861, -0.99655, 0.0631846, 0.053814, 29.2925, 0, 0, 0, 1;
//    -0.274195, -0.958249, -0.0810923, 82.7295, 0.769264, -0.269156, 0.579471, -31.2526, -0.577104, 0.0965066, 0.810948, -36.7443, 0, 0, 0, 1;
//    -0.108551, -0.84774, 0.519185, 34.782, 0.0476049, -0.526105, -0.849086, 72.5254, 0.99295, -0.0674531, 0.0974657, 24.625, 0, 0, 0, 1;
//    -0.473088, -0.139488, 0.869903, 7.44697, 0.823739, 0.28017, 0.492908, -39.6921, -0.312475, 0.949762, -0.0176429, 30.5169, 0, 0, 0, 1;
//    -0.490762, 0.0453919, 0.87011, 28.5485, -0.821906, 0.307326, -0.479606, 26.4766, -0.289177, -0.950521, -0.113516, -1.39476, 0, 0, 0, 1;
//    0.833895, -0.238531, 0.497718, 40.3887, 0.454608, -0.214516, -0.864474, 59.8128, 0.312972, 0.947146, -0.0704453, 39.1566, 0, 0, 0, 1;
//    -0.93185, 0.118497, 0.342948, 14.5041, -0.362379, -0.256166, -0.896136, 135.702, -0.0183384, -0.959342, 0.281649, 15.6166, 0, 0, 0, 1;
//    0.423593, -0.191701, 0.885336, 10.4275, -0.400836, 0.836793, 0.372972, -1.91617, -0.812342, -0.512863, 0.277619, 25.6658, 0, 0, 0, 1;
//    0.511954, -0.743237, 0.430699, 50.6305, -0.535218, -0.668159, -0.516822, 2.15791, 0.671897, 0.0340712, -0.739861, 91.2694, 0, 0, 0, 1;
//    0.12973, 0.742652, 0.656992, 29.2179, 0.462088, 0.54096, -0.702735, 10.3112, -0.877294, 0.394754, -0.272992, 65.1481, 0, 0, 0, 1;
//    -0.0336522, -0.788316, -0.61435, 176.054, -0.0111798, -0.614363, 0.788944, -126.624, -0.999371, 0.033418, 0.0118615, 37.2759, 0, 0, 0, 1;
//    0.628804, -0.102774, -0.770742, 208.635, -0.768683, 0.0672163, -0.636088, 121.527, 0.11718, 0.992431, -0.0367346, 60.8508, 0, 0, 0, 1;
//    0.993933, -0.107636, 0.0226284, 70.9187, 0.0332942, 0.0983513, -0.994595, 92.8161, 0.104829, 0.989314, 0.101338, 47.6193, 0, 0, 0, 1;
//    0.0316924, -0.922653, 0.384326, 60.6505, -0.998334, -0.0477734, -0.0323646, 23.1508, 0.0482217, -0.38266, -0.92263, 135.825, 0, 0, 0, 1;
//    0.826591, 0.556757, 0.0822761, 90.3082, -0.515096, 0.807299, -0.288002, 45.5367, -0.226769, 0.19568, 0.954089, -28.7997, 0, 0, 0, 1;
//    0.944777, -0.151529, -0.290577, 116.938, -0.318874, -0.220512, -0.921789, 196.96, 0.0756023, 0.963542, -0.256653, 102.456, 0, 0, 0, 1;
//    0.928337, 0.182493, -0.323863, 71.0998, 0.360098, -0.225135, 0.905342, 15.1813, 0.0923051, -0.957084, -0.274716, 69.3761, 0, 0, 0, 1;
//    -0.963935, -0.247965, -0.0966596, 51.0179, 0.264075, -0.845999, -0.463196, 62.291, 0.0330826, -0.472016, 0.880968, 1.52149, 0, 0, 0, 1;
//    -0.921382, -0.281516, 0.267961, 36.6358, 0.203384, -0.936759, -0.284813, 64.413, 0.331194, -0.207922, 0.920369, -3.7743, 0, 0, 0, 1;
//    0.181487, -0.983193, -0.0198299, 62.9697, -0.0315476, -0.0259753, 0.999164, -87.5647, -0.982887, -0.18071, -0.0357316, 46.2073, 0, 0, 0, 1;

///Coffee Mug
//   -0.949314, 0.300834, 0.0911125, 85.9569, -0.0858197, 0.0307915, -0.995835, 52.3854, -0.302386, -0.953179, -0.00341326, 67.3304, 0, 0, 0, 1;
//    0.092143, 0.00889151, -0.995706, 159.886, -0.983362, -0.156402, -0.0923974, 35.5113, -0.156552, 0.987653, -0.00566768, -18.3769, 0, 0, 0, 1;
//    -0.0675251, -0.621749, -0.780301, 135.132, -0.0932638, -0.774728, 0.625379, -47.4525, -0.993349, 0.115003, -0.00567309, 14.6236, 0, 0, 0, 1;
//    -0.0299445, -0.625887, 0.779338, 31.5591, -0.0469466, -0.777947, -0.626574, 35.7804, 0.998448, -0.0553497, -0.0060881, 53.661, 0, 0, 0, 1;
//    -0.963706, 0.196833, -0.180353, 122.114, 0.152803, 0.960654, 0.231937, -4.1474, 0.21891, 0.195961, -0.955865, 91.5409, 0, 0, 0, 1;
//    -0.535657, -0.335476, -0.774937, 135.659, 0.419919, -0.902011, 0.100229, 0.0111818, -0.732625, -0.271722, 0.624041, -12.4267, 0, 0, 0, 1;
//    0.018189, -0.680274, -0.732732, 129.747, 0.0099614, -0.732694, 0.680486, -52.5856, -0.999784, -0.0196764, -0.00655051, 20.7321, 0, 0, 0, 1;
//    0.219832, 0.548863, 0.806488, 39.2711, 0.309337, 0.744829, -0.591219, 29.1218, -0.925194, 0.379446, -0.00604583, 50.8169, 0, 0, 0, 1;
//    -0.757692, 0.561254, -0.333012, 113.299, 0.623763, 0.772858, -0.116663, 2.58985, 0.191893, -0.296115, -0.935678, 89.542, 0, 0, 0, 1;
//    -0.0724048, -0.963166, -0.258976, 74.4803, -0.0255275, -0.257783, 0.965866, -84.8062, -0.997049, 0.0765444, -0.00592251, 71.6527, 0, 0, 0, 1;
//    -0.0926301, 0.691634, 0.716284, 31.6838, -0.273801, 0.673951, -0.686165, 45.0366, -0.957315, -0.259679, 0.126942, 65.8697, 0, 0, 0, 1;
//    -0.399432, 0.304457, -0.864731, 140.716, -0.68067, 0.533368, 0.502201, -30.3648, 0.614119, 0.789192, -0.00580913, 50.7965, 0, 0, 0, 1;
//    0.37596, -0.56199, 0.736764, 41.9062, -0.416887, 0.607504, 0.676124, 22.248, -0.827562, -0.561343, -0.00588869, 50.8161, 0, 0, 0, 1;
//    0.721085, -0.142299, -0.678076, 117.987, -0.692804, -0.158892, -0.703402, 100.654, -0.00764697, 0.976987, -0.21316, 74.0731, 0, 0, 0, 1;
//    -0.962794, 1.25697e-10, 0.270237, 113.606, -0.270237, -7.34048e-09, -0.962794, 85.4694, 1.68316e-09, -1, 2.55042e-09, 11, 0, 0, 0, 1;
//    -0.215822, -0.859246, 0.463807, 41.4929, 0.409629, 0.351507, 0.841811, -6.52895, -0.886355, 0.37167, 0.276109, 51.733, 0, 0, 0, 1;
//    -0.472017, -0.111517, 0.874508, 31.5819, -0.88131, 0.0347441, -0.471258, 32.309, 0.0221695, -0.993155, -0.114681, 19.1134, 0, 0, 0, 1;
//    -0.205574, 0.894797, 0.39633, 41.9132, 0.0351999, -0.397957, 0.916729, -30.3641, 0.978008, 0.202406, 0.0503126, 70.4854, 0, 0, 0, 1;
//    -0.000842955, 0.446871, 0.894598, 39.993, -0.0990588, 0.890161, -0.444748, 28.0459, -0.995081, -0.0889928, 0.0435162, 50.5755, 0, 0, 0, 1;
//    -0.787412, 0.590586, -0.176611, 70.2846, 0.616345, 0.759003, -0.20984, 54.71, 0.0101201, -0.274083, -0.961653, 148.427, 0, 0, 0, 1;
//    -0.0394773, -0.998591, -0.0354563, 55.7564, -0.991553, 0.0347623, 0.124959, -11.9963, -0.12355, 0.0400897, -0.991528, 151.179, 0, 0, 0, 1;
//    -0.483114, -0.869814, -0.100129, 92.938, -0.00651467, 0.117928, -0.993, 75.7282, 0.875534, -0.47908, -0.0626393, -19.3061, 0, 0, 0, 1;
//    0.926971, -0.372365, -0.0455004, 60.3896, -0.37513, -0.920735, -0.107355, 60.3712, -0.00191873, 0.116584, -0.993178, 115.676, 0, 0, 0, 1;
//    0.083891, 0.632801, 0.769757, 17.1011, 0.110714, 0.761778, -0.638308, 47.1855, -0.990305, 0.138771, -0.00615338, 113.817, 0, 0, 0, 1;
//    0.115633, 0.0393193, 0.992513, 38.1177, 0.604062, 0.790422, -0.101689, 25.5764, -0.788503, 0.611299, 0.0676473, 50.4213, 0, 0, 0, 1;
//    0.600525, 0.796206, -0.0736566, 78.2273, 0.798443, -0.592135, 0.108927, -23.1382, 0.0431138, -0.124224, -0.991317, 116.866, 0, 0, 0, 1;
//    0.960389, -0.278661, 3.51099e-08, 68.5892, -0.278661, -0.960389, 1.40561e-08, 41.721, 0, 0, -1, 57.1117, 0, 0, 0, 1;
//    0.100368, 0.342481, 0.934149, 38.1066, -0.464354, -0.814239, 0.348411, 22.1091, 0.879944, -0.468744, 0.0773088, 50.3459, 0, 0, 0, 1;
//    0.178865, -0.511865, -0.840239, 125.525, 0.073651, -0.844649, 0.53023, -28.7834, -0.981113, -0.156724, -0.113379, 76.4989, 0, 0, 0, 1;
//    0.451159, -0.876499, 0.167942, 41.3897, -0.0635412, -0.219253, -0.973597, 41.8311, 0.890179, 0.428576, -0.154612, 82.8018, 0, 0, 0, 1;

///MilkBottle
//    0.20478, 0.961595, -0.182758, 9.36993, -0.0380663, -0.17875, -0.983158, 28.5627, -0.978067, 0.208288, -6.70552e-08, 1.5695, 0, 0, 0, 1;
//    -0.957576, -0.269356, -0.102436, -510.308, -0.277522, 0.957709, 0.0759899, -1148.14, 0.077636, 0.101195, -0.991833, 98.5434, 0, 0, 0, 1;
//    0.946207, -0.287388, 0.148662, 1136.62, -0.147495, -0.792045, -0.592376, 685.668, 0.287989, 0.538584, -0.791827, -167.337, 0, 0, 0, 1;
//    -0.642996, -0.747679, -0.16593, 228.284, 0.379941, -0.499523, 0.778538, 716.606, -0.664982, 0.437553, 0.605265, -1087.19, 0, 0, 0, 1;
//    0.969745, -0.243828, -0.0119596, 1118.01, -0.240252, -0.961915, 0.130376, 741.448, -0.0432932, -0.123558, -0.991392, 278.163, 0, 0, 0, 1;
//    -0.329698, 0.731724, -0.596556, -848.445, 0.217062, 0.673711, 0.706398, -544.587, 0.918794, 0.103409, -0.38095, 799.414, 0, 0, 0, 1;
//    3.32543e-07, 0.957788, 0.287473, 44.6561, 8.42525e-08, 0.287473, -0.957788, 14.2241, -1, 3.43973e-07, -5.66408e-09, 560, 0, 0, 0, 1;
//    -0.838064, -0.386217, -0.385337, -223.202, 0.423019, -0.906042, -0.0119061, 1264.32, -0.344534, -0.172983, 0.922698, -201.547, 0, 0, 0, 1;
//    -0.280084, 0.391181, -0.876659, -414.171, 0.95443, 0.0154587, -0.298033, 895.473, -0.103033, -0.920184, -0.377685, 841.094, 0, 0, 0, 1;
//    -0.512094, 0.379254, -0.770667, -623.809, 0.852576, 0.115503, -0.50968, 748.866, -0.104284, -0.918055, -0.382491, 838.84, 0, 0, 0, 1;
//    0.855954, -1.8383e-08, 0.517052, 45.644, -0.517051, -6.10834e-08, 0.855954, 30.9438, -1.82245e-09, -1, -5.741e-09, 557, 0, 0, 0, 1;
//    0.226554, -0.536037, -0.813227, 890.854, 0.512012, -0.644722, 0.567607, 993.599, -0.828563, -0.544975, 0.128393, -242.876, 0, 0, 0, 1;
//    -0.12973, -0.00110912, -0.991549, 98.1843, -0.110573, 0.993778, 0.0133552, -1025.55, 0.985365, 0.111371, -0.129046, 808.589, 0, 0, 0, 1;
//    -0.768416, -0.463776, -0.440963, -90.7889, 0.278547, -0.862749, 0.421991, 1004.52, -0.576149, 0.201436, 0.792133, -801.566, 0, 0, 0, 1;
//    0.16208, -0.892798, -0.420287, 1095.75, 0.822178, 0.357707, -0.442796, 458.403, 0.545668, -0.273782, 0.792017, 691.104, 0, 0, 0, 1;
//    0.197823, -0.189111, -0.961823, 557.639, -0.290348, 0.925878, -0.241761, -1073.74, 0.93625, 0.32709, 0.128252, 462.411, 0, 0, 0, 1;
//    0.412124, 0.524047, -0.745338, 42.9193, -0.520087, 0.806979, 0.279811, -1253.69, 0.748106, 0.272324, 0.605125, 308.751, 0, 0, 0, 1;
//    0.0337923, 0.631008, -0.77504, -405.26, -0.63387, -0.586027, -0.504758, 113.331, -0.772701, 0.508332, 0.380174, -1225.72, 0, 0, 0, 1;
//    -0.244735, 0.865379, -0.437291, -925.149, -0.191718, -0.485292, -0.853074, 460.5, -0.950447, -0.12494, 0.284677, -770.194, 0, 0, 0, 1;
//    0.436588, -0.127205, -0.890623, 706.44, 0.2332, -0.940117, 0.24859, 1079.95, -0.868912, -0.316225, -0.380779, -411.524, 0, 0, 0, 1;
//    0.618256, -0.376001, -0.690205, 1056.19, -0.68912, 0.162995, -0.706078, -614.905, 0.377986, 0.912171, -0.158337, -490.048, 0, 0, 0, 1;
//    0.740896, -0.245317, -0.625214, 1017.17, -0.618079, -0.613272, -0.491809, 148.459, -0.262777, 0.750811, -0.605996, -812.38, 0, 0, 0, 1;
//    -0.335784, 0.82239, -0.459265, -970.17, -0.747409, -0.529358, -0.401448, -66.3097, -0.573262, 0.208459, 0.792412, -755.014, 0, 0, 0, 1;
//    0.804254, -0.457145, 0.379731, 1165.38, 0.097029, -0.529388, -0.842813, 643.639, 0.586313, 0.71468, -0.381405, -80.8213, 0, 0, 0, 1;
//    -0.248501, 0.891181, -0.379531, -998.213, -0.967902, -0.243661, 0.0615986, -585.608, -0.0375814, 0.382656, 0.923126, -385.609, 0, 0, 0, 1;
//    0.339253, 0.605921, 0.71956, -295.262, -0.327634, -0.640922, 0.694172, 301.168, 0.881795, -0.471252, -0.0189147, 1377.73, 0, 0, 0, 1;
//    -0.0163507, 0.99811, -0.0592072, -892.093, -0.998531, -0.0193583, -0.0505874, -799.446, -0.051638, 0.0582931, 0.996964, -167.856, 0, 0, 0, 1;
//    0.306957, 0.906268, 0.290612, -575.421, 0.88935, -0.381864, 0.251467, 1146.06, 0.338871, 0.181267, -0.923205, 256.824, 0, 0, 0, 1;
//    0.742158, 0.65901, -0.122099, 103.922, -0.658797, 0.750794, 0.0479038, -1286.55, 0.12324, 0.0448866, 0.991361, -1.1053, 0, 0, 0, 1;
//    -0.365886, -0.906613, -0.21019, 605.128, 0.288937, -0.32535, 0.900368, 557.446, -0.884671, 0.268701, 0.380995, -964.639, 0, 0, 0, 1;

//BabyBottle
//    -0.0787739, -0.277242, -0.957566, 137.871, -0.423268, -0.860368, 0.283921, -11.9385, -0.902574, 0.427672, -0.049573, -2.61595, 0, 0, 0, 1;
//    -0.656684, 0.742998, 0.129306, 45.9026, 0.751127, 0.659728, 0.0237894, 42.4251, -0.0676315, 0.112748, -0.991319, 78.846, 0, 0, 0, 1;
//    0.514425, 0.856545, -0.0411913, 58.4194, -0.011518, -0.0411288, -0.999088, 95.0663, -0.857458, 0.51443, -0.011292, 1.59392, 0, 0, 0, 1;
//    -0.596936, -0.72604, -0.34137, 18.0613, -0.101644, -0.353627, 0.929848, 66.602, -0.795824, 0.589758, 0.137295, 24.732, 0, 0, 0, 1;
//    0.377774, -0.751, -0.541558, 93.0097, 0.204165, -0.502938, 0.839863, -32.4277, -0.903108, -0.427846, -0.0366684, 5.6055, 0, 0, 0, 1;
//    0.194312, 0.412763, -0.88987, 136.228, -0.278393, -0.846657, -0.453508, 63.3537, -0.940606, 0.335856, -0.0496052, -3.4034, 0, 0, 0, 1;
//    0.858599, 0.511559, -0.0333943, 62.097, -0.0170163, 0.0935439, 0.99547, 69.4781, 0.512366, -0.854141, 0.0890214, 49.3923, 0, 0, 0, 1;
//    0.126103, 0.197219, 0.972215, 94.5465, -0.981405, -0.118162, 0.151265, 12.6812, 0.144711, -0.973212, 0.178651, 46.0076, 0, 0, 0, 1;
//    0.589479, -0.106177, -0.800775, 109.278, -0.662973, -0.62995, -0.404512, 38.3688, -0.461498, 0.769344, -0.441735, 43.1774, 0, 0, 0, 1;
//    -0.0916806, -0.971953, 0.216568, 30.3553, -0.25908, -0.186712, -0.947637, 75.1329, 0.961495, -0.142988, -0.234696, 66.0542, 0, 0, 0, 1;
//    -0.99407, -0.104528, -0.0299868, 25.1802, -0.0686252, 0.816914, -0.572662, 37.9246, 0.0843559, -0.567208, -0.819243, 75.2483, 0, 0, 0, 1;
//    0.775245, 0.630489, -0.0384639, 74.4685, -0.631653, 0.773486, -0.0523006, 29.3461, -0.00322375, 0.0648415, 0.99789, 65.1579, 0, 0, 0, 1;
//    -0.494519, 0.203187, 0.845084, 60.0449, -0.639748, 0.573083, -0.512151, -4.87685, -0.588365, -0.793909, -0.153412, 16.7137, 0, 0, 0, 1;
//    -0.338227, 0.888622, -0.309762, 57.2599, 0.337442, -0.192752, -0.921401, 85.6763, -0.878485, -0.416169, -0.234664, 27.9291, 0, 0, 0, 1;
//    -0.387434, -0.673374, -0.629653, 68.4836, -0.554039, 0.715966, -0.424774, 36.0438, 0.736842, 0.18428, -0.650465, 107.378, 0, 0, 0, 1;
//    -0.725923, -0.551622, 0.41079, 48.5154, -0.344643, -0.225127, -0.911339, -20.2837, 0.595195, -0.803138, -0.026688, 46.0026, 0, 0, 0, 1;
//    0.457287, 0.405675, -0.791402, 103.611, -0.401641, -0.699763, -0.590776, 53.2928, -0.793457, 0.588013, -0.157057, 25.0321, 0, 0, 0, 1;
//    0.837576, 0.473616, -0.272312, 74.1101, -0.0121504, -0.482175, -0.875991, 60.551, -0.546186, 0.737017, -0.398104, 36.2493, 0, 0, 0, 1;
//    0.0920734, 0.0417088, -0.994878, 119.907, 0.330675, 0.94114, 0.0700589, 27.1268, 0.939242, -0.335432, 0.072862, 32.8468, 0, 0, 0, 1;
//    0.416558, -0.394008, -0.819291, 102.447, -0.613324, 0.54342, -0.573174, 45.2837, 0.671054, 0.741251, -0.0152882, 49.177, 0, 0, 0, 1;
//    0.66597, -0.740548, 0.0898443, 52.3753, -0.087342, 0.0422031, 0.995284, -50.1379, -0.740848, -0.670676, -0.036575, 8.97164, 0, 0, 0, 1;
//    -0.034467, 0.630108, -0.775742, 90.0168, -0.330154, -0.739805, -0.586248, 53.555, -0.943298, 0.235908, 0.233532, -3.93899, 0, 0, 0, 1;
//    -0.183077, 0.976273, 0.115643, 34.0725, 0.807274, 0.0821579, 0.58443, 2.83299, 0.561062, 0.200351, -0.803161, 91.9361, 0, 0, 0, 1;
//    -0.0665711, -0.0397598, -0.996989, 118.592, 0.986895, 0.144579, -0.0716629, 50.376, 0.146993, -0.988694, 0.0296139, 22.4984, 0, 0, 0, 1;
//    0.176738, -0.421456, -0.88946, 118.462, 0.975008, -0.0486346, 0.216782, 27.5815, -0.134622, -0.905544, 0.402327, -14.484, 0, 0, 0, 1;
//    0.5266, 0.822983, -0.21305, 62.265, -0.000585019, -0.250263, -0.968178, 60.4811, -0.850113, 0.509967, -0.131307, 20.5051, 0, 0, 0, 1;
//    -0.655183, -0.74703, 0.112613, 36.1577, 0.177413, -0.00724893, 0.98411, 74.402, -0.734343, 0.66475, 0.137283, 25.996, 0, 0, 0, 1;
//    0.889152, -0.0174973, -0.457278, 97.4742, 0.45492, -0.0744487, 0.887415, -33.1945, -0.0495711, -0.997071, -0.0582363, 25.1397, 0, 0, 0, 1;
//    -0.768273, -0.63969, -0.0235289, 26.2483, 0.635355, -0.757558, -0.149766, 19.0602, 0.0779795, -0.130011, 0.988441, 58.138, 0, 0, 0, 1;
//    0.580402, -0.794242, 0.179759, 43.588, -0.135994, 0.123108, 0.983031, -50.1877, -0.802894, -0.594999, -0.03656, 46.6799, 0, 0, 0, 1;

    Eigen::Matrix4f Tinv;
    Tinv= transform.inverse();

    // Executing the transformation
    pcl::PointCloud<pcl::PointXYZ>::Ptr transformed_cloud_grasp (new pcl::PointCloud<pcl::PointXYZ> ());
    pcl::transformPointCloud (*Hand_configuration, *transformed_cloud_grasp, Tinv);

    ///GRASP MVBB
    //Compute PCA
    Eigen::Vector4f pcaCentroid;
    pcl::compute3DCentroid(*transformed_cloud_grasp, pcaCentroid);
    Eigen::Matrix3f covariance;
    pcl::computeCovarianceMatrixNormalized(*transformed_cloud_grasp, pcaCentroid, covariance);
    Eigen::SelfAdjointEigenSolver<Eigen::Matrix3f> eigen_solver(covariance, Eigen::ComputeEigenvectors);
    Eigen::Matrix3f eigenVectorsPCA = eigen_solver.eigenvectors();
    eigenVectorsPCA.col(2) = eigenVectorsPCA.col(0).cross(eigenVectorsPCA.col(1));

    //Transform the original grasp point cloud to the origin where the principal component correspond to the axes.
    Eigen::Matrix4f projectionTransform(Eigen::Matrix4f::Identity());
    projectionTransform.block<3,3>(0,0) = eigenVectorsPCA.transpose();
    projectionTransform.block<3,1>(0,3) = -1.f * (projectionTransform.block<3,3>(0,0) * pcaCentroid.head<3>());
    pcl::PointCloud<pcl::PointXYZ>::Ptr cloudPointsProjected(new pcl::PointCloud<pcl::PointXYZ>);
    pcl::transformPointCloud(*transformed_cloud_grasp, *cloudPointsProjected, projectionTransform);
    Projection = projectionTransform;

    // Get the minimum and maximum points of the transformed cloud.
    pcl::PointXYZ minPoint, maxPoint;
    pcl::getMinMax3D(*cloudPointsProjected, minPoint, maxPoint);
    const Eigen::Vector3f meanDiagonal = 0.5f * (maxPoint.getVector3fMap() + minPoint.getVector3fMap());

    // Final transform
    const Eigen::Quaternionf bboxQuaternion(eigenVectorsPCA);
    const Eigen::Vector3f bboxTransform = eigenVectorsPCA * meanDiagonal + pcaCentroid.head<3>();
    BBox_Rotation = bboxQuaternion;
    BBox_Translation = bboxTransform;
    Min[0] = minPoint.x;
    Min[1] = minPoint.y;
    Min[2] = minPoint.z;
    Max[0] = maxPoint.x;
    Max[1] = maxPoint.y;
    Max[2] = maxPoint.z;
    Hand_configuration->clear();
    Hand_configuration = transformed_cloud_grasp;
}

void MVBB::computeNormals(pcl::PointCloud<pcl::PointXYZ>::Ptr C_Object, 
                          pcl::PointCloud<pcl::Normal>::Ptr &Normals, 
                          Eigen::Vector3f &CM) 
                          {

    Eigen::Vector4f centroid;
    pcl::compute3DCentroid (*C_Object, centroid);
    CM << centroid[0], centroid[1], centroid[2];
    //Compute normal vectors
    pcl::NormalEstimationOMP<pcl::PointXYZ, pcl::Normal> ne(8);
    pcl::search::KdTree<pcl::PointXYZ>::Ptr tree(new pcl::search::KdTree<pcl::PointXYZ>());
    ne.setInputCloud(C_Object);
    ne.setSearchMethod(tree);
    ne.setKSearch(40);
    ne.setViewPoint(CM[0],CM[1],CM[2]);
    ne.compute(*Normals);
    cout << "Object normals computed\n";
}

void MVBB::cropFilters(pcl::PointCloud<pcl::PointXYZ>::Ptr C_Object, 
                        pcl::PointCloud<pcl::Normal>::Ptr Normals, 
                        Eigen::Vector4f Min, 
                        Eigen::Vector4f Max, 
                        Eigen::Matrix4f Projection,
                        pcl::PointCloud<pcl::PointXYZ>::Ptr &Points_out, 
                        pcl::PointCloud<pcl::PointXYZ>::Ptr &Points_in, 
                        pcl::PointCloud<pcl::Normal>::Ptr &Normals_ou) 
                        {

    Eigen::Affine3f boxTransform;
    boxTransform.matrix() = Projection;

    //Filter Points Outside the CropBox
    std::vector<int> index;
    pcl::CropBox<pcl::PointXYZ> cropFilterOut; // create the filter
    cropFilterOut.setInputCloud (C_Object); //input the object cloud to be filtered
    cropFilterOut.setMin(Min);
    cropFilterOut.setMax(Max);
    cropFilterOut.setTransform(boxTransform);
    cropFilterOut.setNegative(true);
    cropFilterOut.filter (index);
    pcl::copyPointCloud<pcl::PointXYZ>(*C_Object, index, *Points_out);
    pcl::copyPointCloud<pcl::Normal>(*Normals, index, *Normals_ou);
    float PointsOutside = Points_out->points.size();
    cout << "Object cloud points filtered outside the cropbox: " << PointsOutside << endl;
    //pcl::io::savePCDFile("/home/fernando/PHD/Experiments/objectFilteredOut3.pcd", *Points_out, true);

    //Filter Points Inside the CropBox
    pcl::CropBox<pcl::PointXYZ> cropFilterIn; // create the filter
    cropFilterIn.setInputCloud (C_Object); //input the object cloud to be filtered
    cropFilterIn.setMin(Min);
    cropFilterIn.setMax(Max);
    cropFilterIn.setTransform(boxTransform);
    cropFilterIn.filter (*Points_in);
    float PointsInside = Points_in->points.size() ;
    cout << "Object cloud points filtered inside the cropbox: " << PointsInside << endl;
    //pcl::io::savePCDFile("home/fernando/PHD/Experiments/pcd/DetergentBottleRight/objectFilteredIn3.pcd", *CloudObjectFilteredIn, true);

    float Qt = PointsOutside / (PointsOutside + PointsInside);
    cout << "The QUALITY BASED ON NUMBER OF POINTS IS: "  << Qt << endl;
}

void MVBB::ModelConstruct(pcl::PointCloud<pcl::PointXYZ>::Ptr C_Object, 
                          double &object_area) {

    pcl::NormalEstimation<pcl::PointXYZ, pcl::Normal> n;
    pcl::PointCloud<pcl::Normal>::Ptr normals (new pcl::PointCloud<pcl::Normal>);
    pcl::search::KdTree<pcl::PointXYZ>::Ptr tree (new pcl::search::KdTree<pcl::PointXYZ>);
    tree->setInputCloud (C_Object);
    n.setInputCloud (C_Object);
    n.setSearchMethod (tree);
    n.setKSearch (20);
    n.compute (*normals);

    // Concatenate the XYZ and normal fields*
    pcl::PointCloud<pcl::PointNormal>::Ptr C_ObjectNormals (new pcl::PointCloud<pcl::PointNormal>);
    pcl::concatenateFields (*C_Object, *normals, *C_ObjectNormals);
    //* cloud_with_normals = cloud + normals

    // Create search tree*
    pcl::search::KdTree<pcl::PointNormal>::Ptr tree2 (new pcl::search::KdTree<pcl::PointNormal>);
    tree2->setInputCloud (C_ObjectNormals);

    // Initialize objects
    pcl::GreedyProjectionTriangulation<pcl::PointNormal> gp;
    pcl::PolygonMesh triangles;

    // Set the maximum distance between connected points (maximum edge length)
    gp.setSearchRadius (10000);

    // Set typical values for the parameters
    gp.setMu (5.0);
    gp.setMaximumNearestNeighbors (100);
    gp.setMaximumSurfaceAngle(M_PI / 4); // 45 degrees
    gp.setMinimumAngle(M_PI / 18); // 10 degrees
    gp.setMaximumAngle(2 * (M_PI / 3)); // 120 degrees
    gp.setNormalConsistency(false);

    // Get result
    gp.setInputCloud (C_ObjectNormals);
    gp.setSearchMethod (tree2);
    gp.reconstruct (triangles);

    pcl::io::saveVTKFile("/home/fernando/PHD/Experiments/pcd/BabyBottle/ObjectTriangleMesh.vtk", triangles);

    //calculate area
    pcl::PointCloud<pcl::PointXYZ> cloud_area;
    cloud_area = *C_Object;

    int index_p1, index_p2, index_p3;
    double x1, x2, x3, y1, y2, y3, z1, z2, z3, a, b, c, q;
    object_area = 0;

    for(int i = 0; i < triangles.polygons.size(); i++) {
        index_p1 = triangles.polygons[i].vertices[0];
        index_p2 = triangles.polygons[i].vertices[1];
        index_p3 = triangles.polygons[i].vertices[2];

        x1 = cloud_area.points[index_p1].x;
        y1 = cloud_area.points[index_p1].y;
        z1 = cloud_area.points[index_p1].z;

        x2 = cloud_area.points[index_p2].x;
        y2 = cloud_area.points[index_p2].y;
        z2 = cloud_area.points[index_p2].z;

        x3 = cloud_area.points[index_p3].x;
        y3 = cloud_area.points[index_p3].y;
        z3 = cloud_area.points[index_p3].z;

        //Heron's formula:
        a = sqrt(pow((x1 - x2),2) + pow((y1 - y2),2) + pow((z1 - z2),2));
        b = sqrt(pow((x1 - x3),2) + pow((y1 - y3),2) + pow((z1 - z3),2));
        c = sqrt(pow((x3 - x2),2) + pow((y3 - y2),2) + pow((z3 - z2),2));
        q = (a + b + c) / 2;

        object_area = object_area + sqrt(q * (q - a) * (q - b) * (q - c));
    }
    //cout << "The size of polygon is  " << triangles.polygons.size() << endl;
    cout << "The area of the whole object is: " << object_area << endl;
}

void MVBB::ModelConstruct2(pcl::PointCloud<pcl::PointXYZ>::Ptr Points_out, double &object_area) {

    // Normal estimation*
    pcl::NormalEstimation<pcl::PointXYZ, pcl::Normal> n;
    pcl::PointCloud<pcl::Normal>::Ptr normals (new pcl::PointCloud<pcl::Normal>);
    pcl::search::KdTree<pcl::PointXYZ>::Ptr tree (new pcl::search::KdTree<pcl::PointXYZ>);
    tree->setInputCloud (Points_out);
    n.setInputCloud (Points_out);
    n.setSearchMethod (tree);
    n.setKSearch (20);
    n.compute (*normals);

    // Concatenate the XYZ and normal fields*
    pcl::PointCloud<pcl::PointNormal>::Ptr Points_outNormals (new pcl::PointCloud<pcl::PointNormal>);
    pcl::concatenateFields(*Points_out, *normals, *Points_outNormals);
    //* cloud_with_normals = cloud + normals

    // Create search tree*
    pcl::search::KdTree<pcl::PointNormal>::Ptr tree2 (new pcl::search::KdTree<pcl::PointNormal>);
    tree2->setInputCloud (Points_outNormals);

    // Initialize objects
    pcl::GreedyProjectionTriangulation<pcl::PointNormal> gp3;
    pcl::PolygonMesh triangles;

    // Set the maximum distance between connected points (maximum edge length)
    gp3.setSearchRadius (50000);

    // Set typical values for the parameters
    gp3.setMu (5.0);
    gp3.setMaximumNearestNeighbors (100);
    gp3.setMaximumSurfaceAngle(M_PI / 4); // 45 degrees
    gp3.setMinimumAngle(M_PI / 18); // 10 degrees
    gp3.setMaximumAngle(2 * (M_PI / 3)); // 120 degrees
    gp3.setNormalConsistency(false);

    // Get result
    gp3.setInputCloud (Points_outNormals);
    gp3.setSearchMethod (tree2);
    gp3.reconstruct (triangles);

   // pcl::io::saveVTKFile("/home/fernando/PHD/Experiments/pcd/BabyBottle/BabyBottlePartial1.vtk", triangles);

    //calculate area
    pcl::PointCloud<pcl::PointXYZ> cloud_area;
    cloud_area = *Points_out;

    int index_p1, index_p2, index_p3;
    double x1, x2, x3, y1, y2, y3, z1, z2, z3, a, b, c, q;
    double area = 0;

    for(int i = 0; i < triangles.polygons.size(); i++) {
        index_p1 = triangles.polygons[i].vertices[0];
        index_p2 = triangles.polygons[i].vertices[1];
        index_p3 = triangles.polygons[i].vertices[2];

        x1 = cloud_area.points[index_p1].x;
        y1 = cloud_area.points[index_p1].y;
        z1 = cloud_area.points[index_p1].z;

        x2 = cloud_area.points[index_p2].x;
        y2 = cloud_area.points[index_p2].y;
        z2 = cloud_area.points[index_p2].z;

        x3 = cloud_area.points[index_p3].x;
        y3 = cloud_area.points[index_p3].y;
        z3 = cloud_area.points[index_p3].z;

        //Heron's formula:
        a = sqrt(pow((x1 - x2),2) + pow((y1 - y2),2) + pow((z1 - z2),2));
        b = sqrt(pow((x1 - x3),2) + pow((y1 - y3),2) + pow((z1 - z3),2));
        c = sqrt(pow((x3 - x2),2) + pow((y3 - y2),2) + pow((z3 - z2),2));
        q = (a + b + c) / 2;
        area = area + sqrt(q * (q - a) * (q - b) * (q - c));
    }
    //cout << "The size of polygon is  " << triangles.polygons.size() << endl;
    cout << "The area of the partial object is: " << area  << endl;

    double Qt = area / object_area;
    cout << "THE QUALITY BASED ON THE AREA OF THE OBJECT IS: " << Qt << endl;
}

void MVBB::visualize(pcl::PointCloud<pcl::PointXYZ>::Ptr Hand_configuration, 
                     pcl::PointCloud<pcl::PointXYZ>::Ptr Points_out,
                     Eigen::Vector3f Ctr, 
                     pcl::PointCloud<pcl::PointXYZ>::Ptr Points_in, 
                     Eigen::Vector4f Min,
                     Eigen::Vector4f Max, 
                     Eigen::Quaternionf BBox_Rotation, 
                     Eigen::Vector3f BBox_Translation, 
                     bool f_coordinates)
                     {

    pcl::visualization::PCLVisualizer BBox_Visualizer ("3D Viewer");
    pcl::visualization::PointCloudColorHandlerCustom<pcl::PointXYZ> filteredColorOut(Points_out, 0, 255, 0); //Points out the box (green)
    pcl::visualization::PointCloudColorHandlerCustom<pcl::PointXYZ> filteredColorIn(Points_in, 0, 0, 255);  //Points in the box (blue)
    pcl::visualization::PointCloudColorHandlerCustom<pcl::PointXYZ> grasp_cloud (Hand_configuration, 255, 0, 0); //Grasp (red)
    BBox_Visualizer.setBackgroundColor(255,255,255); // white background
    BBox_Visualizer.addPointCloud(Points_out, filteredColorOut, "cloud_out");
    BBox_Visualizer.addPointCloud(Points_in, filteredColorIn, "cloud_in");
    BBox_Visualizer.addPointCloud(Hand_configuration, grasp_cloud, "grasp_cloud");
    BBox_Visualizer.setPointCloudRenderingProperties(pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 2.8, "cloud_out");
    BBox_Visualizer.setPointCloudRenderingProperties(pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 2.8, "cloud_in");
    BBox_Visualizer.setPointCloudRenderingProperties(pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 2.2, "grasp_cloud");

    if(f_coordinates) {
        BBox_Visualizer.addCoordinateSystem(10,"world",0);
        BBox_Visualizer.addCoordinateSystem(10,Ctr[0],Ctr[1],Ctr[2],"centroid",0);
    }

    BBox_Visualizer.addCube(BBox_Translation, BBox_Rotation, Max[0] - Min[0], Max[1] - Min[1], Max[2] - Min[2], "boundingbox", 0);
    BBox_Visualizer.setRepresentationToWireframeForAllActors();
    BBox_Visualizer.setShapeRenderingProperties(pcl::visualization::PCL_VISUALIZER_COLOR, 0.0, 0.0, 0.0, "boundingbox");
    BBox_Visualizer.setShapeRenderingProperties(pcl::visualization::PCL_VISUALIZER_LINE_WIDTH, 4, "boundingbox");
    BBox_Visualizer.setShapeRenderingProperties(pcl::visualization::PCL_VISUALIZER_OPACITY, 0.2, "boundingbox");

    while(!BBox_Visualizer.wasStopped()) {
        BBox_Visualizer.spinOnce();
    }
    BBox_Visualizer.close();
}

